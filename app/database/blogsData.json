{
  "blogPosts": [
    {
      "id": 4,
      "slug": "understanding-rails-view-rendering",
      "url": "/blogs/understanding-rails-view-rendering",
      "title": "Understanding Rails View Rendering: Behind the ERB Magic",
      "excerpt": "A deep dive into how Ruby on Rails transforms ERB templates into HTML, exploring the internal rendering process...",
      "date": "November 19, 2024",
      "readTime": "4 min read",
      "tags": ["Ruby on Rails", "ActionView", "ERB", "Ruby"],
      "content": "<p>Ruby on Rails encapsulates a lot of complexity, allowing developers to focus on writing features without worrying about its internal. For the longest time, I wanted to understand what exactly happens when render is invoked in a Rails controller. Specifically, I was curious about how Rails parses ERB tags (&lt;% %&gt;, &lt;%= %&gt;) in the view. This blog post is based on a recent talk I gave at my local Ruby meetup (September 2024 meeting · Luma).</p><p>This blog assumes the reader has a basic understanding of the Rails framework. If you're new to Rails, I recommend reading this guide to get familiar with the basics.</p><h2>For a contrived example</h2><p>Let's say we have a UsersController and its associated index view template.</p><pre><code class=\"language-ruby\">class UsersController < ApplicationController\n  def index\n    @user_email = \"shard@gmail.com\"\n  end\nend\n\n# app/views/users/index.html.erb\n# <ActionView::Base:0x00000000009bf0> instance view object\n\"<h1>Welcome  <%= @user_email %> to the Landing Page</h1>\"</code></pre><p>Views are rendered in the context of the ActionView::Base class.</p><h2>The Rendering Flow</h2><p>Let's visualize the rendering process before diving into the details:</p><ol><li>Controller Action called</li><li>Rails finds the ERB template</li><li>Template compiled to Ruby method</li><li>Method executes, generates HTML</li></ol><h2>The Transformation Process</h2><p>How does rails transform the HTML source code in the view template?</p><p>From:<br>\"&lt;h1&gt;Welcome  &lt;%= @user_email %&gt; to the Landing Page&lt;/h1&gt;\"</p><p>To:<br>\"&lt;h1&gt;Welcome shard@gmail.com to the Landing Page&lt;/h1&gt;\"</p><p>After exploring both the ActionPack and ActionView modules, which are the primary components responsible for handling requests, responses, and template rendering. Here's the breakdown of the rendering process that happens behind the scenes.</p><h2>The Rendering Process</h2><p>When def index action is called in a controller:</p><p>render is invoked implicitly in AbstractController::Rendering:23:</p><pre><code class=\"language-ruby\">def render(*args, &block)\n  options = _normalize_render(*args, &block)\n  rendered_body = render_to_body(options)\n  if options[:html]\n    _set_html_content_type\n  else\n    _set_rendered_content_type rendered_format\n  end\n  _set_vary_header\n  self.response_body = rendered_body\nend</code></pre><h3>1. _normalize_render (after Controller Action called):</h3><p>This method creates an options hash to provide context on the view template location and which view to render.</p><pre><code>options = { template: 'index', prefixes: [\"users\", \"application\"] }</code></pre><h3>2. render_to_body (find template):</h3><p>This method handles the actual view template rendering. Although render_to_body is called in several modules within ActionController and AbstractController, the render_to_body in ActionView::Rendering:105 is the key entry point for view rendering.</p><p>From there, ActionView looks up the template using the LookupContext class, parses the template path using the PathParser, and returns the extracted values in a hash.</p><pre><code>path = 'app/views/users/index.html.erb' \ndetails = {\n :prefix=>\"/Users/shardly/Documents/Main/Pet_Projects/shoe_stride/app/views/static_pages\", \n :action=>\"index\", \n :partial=>false, \n :locale=>nil, \n :handler=>:erb, \n :format=>:html, \n :variant=>nil\n}</code></pre><p>After some additional steps, an instance of the TemplateRenderer class creates an instance of the Template class, passing arguments like :handler(erb, haml), :format(HTML, js, etc), :variant (mobile, desktop) and a couple more.</p><h3>3. Compiled to Ruby method:</h3><p>Next, the compile method in the Template class is invoked, dynamically creating an instance method. Based on the HTML source code, the generated method would look like the example shown below.</p><pre><code class=\"language-ruby\">source = def _app_views_users_index_html_erb___3847165856814041552_19860(local_assigns, output_buffer)\n            @virtual_path = \"users/index\"\n            @output_buffer.safe_append='<h1>Welcome '.freeze\n            @output_buffer.append=( @user_email )\n            @output_buffer.safe_append=' to the Landing Page<h1>'.freeze;\n            @output_buffer.to_s\n          end</code></pre><p>The @output_buffer is an instance of the OutputBuffer class in the ActionView module. It is responsible for accumulating the rendered HTML content in Rails views. It is vital to manage how Ruby expressions, helpers, and templates are processed and outputted as complete HTML responses. It also ensures efficient rendering and proper HTML escaping.</p><p>The new instance method (`_app_views_users…`) is then added to the &lt;ActionView::Base:0x00000000009bf0&gt; class through module_eval:</p><pre><code class=\"language-ruby\"># mod = <ActionView::Base:0x00000000009bf0>\nmod.module_eval(source, identifier, 0)</code></pre><h3>4. Generate html:</h3><p>Finally, def _run is invoked on the ActionView::Base object, which in turn calls public_send, invoking the dynamically created method:</p><pre><code class=\"language-ruby\"># method = \"_app_views_users_index_html_erb___3847165856814041552_19860\"\n\ndef _run(method, template, locals, buffer, add_to_stack: true, &block)\n  _old_output_buffer, _old_virtual_path, _old_template = @output_buffer, @virtual_path, @current_template\n  @current_template = template if add_to_stack\n  @output_buffer = buffer\n  public_send(method, locals, buffer, &block)</code></pre><p>public_send will return:</p><pre><code>\"<h1>Welcome shard@gmail.com to the Landing Page<h1>\"</code></pre><p>That's it!</p><h2>Wrapping Up</h2><p>A key takeaway here is how Rails dynamically creates and evaluates methods during template rendering. Ruby allows you to use module_eval to define methods on the fly on a class, such as in this example:</p><pre><code class=\"language-ruby\">class Post\nend\n\npost = Post.new\n\nPost.module_eval do\n  def comment\n    'my comment'\n  end\nend\n\npost.comment #=> \"my comment\"</code></pre><p>Rails modules come with built-in debugging tools like debugger, which made this research much easier. You can open a module in your preferred IDE by running:</p><pre><code>$ sample_rails_project git:(main) > EDITOR=code bundle open actionview\n$ sample_rails_project git:(main) > EDITOR=code bundle open actionpack</code></pre><p>If you make any changes while exploring, you can reset the files to their original state by running:</p><pre><code>$ sample_rails_project git:(main) > gem pristine actionview\n$ sample_rails_project git:(main) > gem pristine actionpack</code></pre><h2>Conclusion</h2><p>Exploring Rails' source code has deepened my appreciation for the framework, and I learned some interesting Ruby concepts along the way. The framework extensively follows the SOLID principles, with the Single Responsibility Principle being particularly evident in many of its classes. Through this research, I also discovered some text documentation that needs to be updated in the ActionPack module, for which I have submitted a pull request. I hope this blog post empowers you to explore the underlying mechanics of the tools you're using.</p><p>Go out and explore yourself it is a rewarding experience.</p><p>Thanks for reading!</p>"
    },
    {
      "id": 1,
      "slug": "optimizing-rails-applications",
      "url": "/blogs/optimizing-rails-applications",
      "title": "Optimizing Rails Applications: Solving the N+1 Query Problem",
      "excerpt": "Learn how to identify and fix performance bottlenecks in Rails applications by addressing the common N+1 query issue...",
      "date": "January 22, 2025",
      "readTime": "2 min read",
      "tags": ["Ruby on Rails", "Performance", "Database"],
      "content": "<p>One of the most common performance issues in Rails applications is the N+1 query problem. This occurs when your code executes N additional queries to fetch related data for N records, instead of fetching all the necessary data in a single query.</p><h2>Understanding the N+1 Problem</h2><p>Consider a situation where you have a blog with posts and comments. If you want to display all posts with their comments, a naive approach might look like this:</p><pre><code class=\"language-ruby\"># Controller index\n@posts = Post.all\n\n# In your view\n@posts.each do |post|\n  post.comments.each do |comment|\n    # Display comment\n  end\nend</code></pre><p>This code will execute one query to fetch all posts, and then one additional query for each post to fetch its comments. If you have 100 posts, this results in 101 database queries!</p><h2>Solution: Eager Loading</h2><p>Rails provides a simple solution through eager loading with the <code>includes</code> method:</p><pre><code class=\"language-ruby\">@posts = Post.includes(:comments).all</code></pre><p>This generates just two queries:</p><pre><code class=\"language-sql\">SELECT * FROM posts;\nSELECT * FROM comments WHERE post_id IN (1, 2, 3, ...);</code></pre><p>The <code>includes</code> method tells Rails to load the associated records in a separate query, and then merge the results in memory.</p><h2>Advanced Eager Loading</h2><p>For more complex relationships, you can nest your includes:</p><pre><code class=\"language-ruby\">@posts = Post.includes(comments: :user).all</code></pre><p>This will eager load comments and their associated users in just three queries, regardless of how many posts, comments, or users you have.</p><h2>Identifying N+1 Queries</h2><p>Tools like the Bullet gem can help you identify N+1 queries in your application. Add it to your Gemfile:</p><pre><code class=\"language-ruby\">gem 'bullet', group: :development</code></pre><p>Bullet will notify you when it detects N+1 queries in your application, helping you to identify and fix performance bottlenecks.</p><h2>Conclusion</h2><p>Solving N+1 query problems is one of the easiest ways to improve the performance of your Rails application. By using eager loading appropriately, you can dramatically reduce the number of database queries your application makes, resulting in faster response times and a better user experience.</p>"
    }
  ]
}
