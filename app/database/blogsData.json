{
  "blogPosts": [
    {
      "id": 4,
      "slug": "understanding-rails-view-rendering",
      "url": "/blogs/understanding-rails-view-rendering",
      "title": "Understanding Rails View Rendering: Behind the ERB Magic",
      "excerpt": "A deep dive into how Ruby on Rails transforms ERB templates into HTML, exploring the internal rendering process...",
      "date": "November 19, 2024",
      "readTime": "4 min read",
      "tags": ["Ruby on Rails", "ActionView", "ERB", "Ruby"],
      "keywords": ["Rails views", "Rails view rendering", "Rails templates", "Rails partials", "Rails layouts", "Rails view helpers", "ERB templates", "view rendering" ],
      "content": "<p>Ruby on Rails encapsulates a lot of complexity, allowing developers to focus on writing features without worrying about its internal. For the longest time, I wanted to understand what exactly happens when render is invoked in a Rails controller. Specifically, I was curious about how Rails parses ERB tags (&lt;% %&gt;, &lt;%= %&gt;) in the view. This blog post is based on a recent talk I gave at my local Ruby meetup (September 2024 meeting · Luma).</p><p>This blog assumes the reader has a basic understanding of the Rails framework. If you're new to Rails, I recommend reading this guide to get familiar with the basics.</p><h2>For a contrived example</h2><p>Let's say we have a UsersController and its associated index view template.</p><pre><code class=\"language-ruby\">class UsersController < ApplicationController\n  def index\n    @user_email = \"shard@gmail.com\"\n  end\nend\n\n# app/views/users/index.html.erb\n# <ActionView::Base:0x00000000009bf0> instance view object\n\"<h1>Welcome  <%= @user_email %> to the Landing Page</h1>\"</code></pre><p>Views are rendered in the context of the ActionView::Base class.</p><h2>The Rendering Flow</h2><p>Let's visualize the rendering process before diving into the details:</p><ol><li>Controller Action called</li><li>Rails finds the ERB template</li><li>Template compiled to Ruby method</li><li>Method executes, generates HTML</li></ol><h2>The Transformation Process</h2><p>How does rails transform the HTML source code in the view template?</p><p>From:<br>\"&lt;h1&gt;Welcome  &lt;%= @user_email %&gt; to the Landing Page&lt;/h1&gt;\"</p><p>To:<br>\"&lt;h1&gt;Welcome shard@gmail.com to the Landing Page&lt;/h1&gt;\"</p><p>After exploring both the ActionPack and ActionView modules, which are the primary components responsible for handling requests, responses, and template rendering. Here's the breakdown of the rendering process that happens behind the scenes.</p><h2>The Rendering Process</h2><p>When def index action is called in a controller:</p><p>render is invoked implicitly in AbstractController::Rendering:23:</p><pre><code class=\"language-ruby\">def render(*args, &block)\n  options = _normalize_render(*args, &block)\n  rendered_body = render_to_body(options)\n  if options[:html]\n    _set_html_content_type\n  else\n    _set_rendered_content_type rendered_format\n  end\n  _set_vary_header\n  self.response_body = rendered_body\nend</code></pre><h3>1. _normalize_render (after Controller Action called):</h3><p>This method creates an options hash to provide context on the view template location and which view to render.</p><pre><code>options = { template: 'index', prefixes: [\"users\", \"application\"] }</code></pre><h3>2. render_to_body (find template):</h3><p>This method handles the actual view template rendering. Although render_to_body is called in several modules within ActionController and AbstractController, the render_to_body in ActionView::Rendering:105 is the key entry point for view rendering.</p><p>From there, ActionView looks up the template using the LookupContext class, parses the template path using the PathParser, and returns the extracted values in a hash.</p><pre><code>path = 'app/views/users/index.html.erb' \ndetails = {\n :prefix=>\"/Users/shardly/Documents/Main/Pet_Projects/shoe_stride/app/views/static_pages\", \n :action=>\"index\", \n :partial=>false, \n :locale=>nil, \n :handler=>:erb, \n :format=>:html, \n :variant=>nil\n}</code></pre><p>After some additional steps, an instance of the TemplateRenderer class creates an instance of the Template class, passing arguments like :handler(erb, haml), :format(HTML, js, etc), :variant (mobile, desktop) and a couple more.</p><h3>3. Compiled to Ruby method:</h3><p>Next, the compile method in the Template class is invoked, dynamically creating an instance method. Based on the HTML source code, the generated method would look like the example shown below.</p><pre><code class=\"language-ruby\">source = def _app_views_users_index_html_erb___3847165856814041552_19860(local_assigns, output_buffer)\n            @virtual_path = \"users/index\"\n            @output_buffer.safe_append='<h1>Welcome '.freeze\n            @output_buffer.append=( @user_email )\n            @output_buffer.safe_append=' to the Landing Page<h1>'.freeze;\n            @output_buffer.to_s\n          end</code></pre><p>The @output_buffer is an instance of the OutputBuffer class in the ActionView module. It is responsible for accumulating the rendered HTML content in Rails views. It is vital to manage how Ruby expressions, helpers, and templates are processed and outputted as complete HTML responses. It also ensures efficient rendering and proper HTML escaping.</p><p>The new instance method (`_app_views_users…`) is then added to the &lt;ActionView::Base:0x00000000009bf0&gt; class through module_eval:</p><pre><code class=\"language-ruby\"># mod = <ActionView::Base:0x00000000009bf0>\nmod.module_eval(source, identifier, 0)</code></pre><h3>4. Generate html:</h3><p>Finally, def _run is invoked on the ActionView::Base object, which in turn calls public_send, invoking the dynamically created method:</p><pre><code class=\"language-ruby\"># method = \"_app_views_users_index_html_erb___3847165856814041552_19860\"\n\ndef _run(method, template, locals, buffer, add_to_stack: true, &block)\n  _old_output_buffer, _old_virtual_path, _old_template = @output_buffer, @virtual_path, @current_template\n  @current_template = template if add_to_stack\n  @output_buffer = buffer\n  public_send(method, locals, buffer, &block)</code></pre><p>public_send will return:</p><pre><code>\"<h1>Welcome shard@gmail.com to the Landing Page<h1>\"</code></pre><p>That's it!</p><h2>Wrapping Up</h2><p>A key takeaway here is how Rails dynamically creates and evaluates methods during template rendering. Ruby allows you to use module_eval to define methods on the fly on a class, such as in this example:</p><pre><code class=\"language-ruby\">class Post\nend\n\npost = Post.new\n\nPost.module_eval do\n  def comment\n    'my comment'\n  end\nend\n\npost.comment #=> \"my comment\"</code></pre><p>Rails modules come with built-in debugging tools like debugger, which made this research much easier. You can open a module in your preferred IDE by running:</p><pre><code>$ sample_rails_project git:(main) > EDITOR=code bundle open actionview\n$ sample_rails_project git:(main) > EDITOR=code bundle open actionpack</code></pre><p>If you make any changes while exploring, you can reset the files to their original state by running:</p><pre><code>$ sample_rails_project git:(main) > gem pristine actionview\n$ sample_rails_project git:(main) > gem pristine actionpack</code></pre><h2>Conclusion</h2><p>Exploring Rails' source code has deepened my appreciation for the framework, and I learned some interesting Ruby concepts along the way. The framework extensively follows the SOLID principles, with the Single Responsibility Principle being particularly evident in many of its classes. Through this research, I also discovered some text documentation that needs to be updated in the ActionPack module, for which I have submitted a pull request. I hope this blog post empowers you to explore the underlying mechanics of the tools you're using.</p><p>Go out and explore yourself it is a rewarding experience.</p><p>Thanks for reading!</p>"
    },
    {
      "id": 1,
      "slug": "optimizing-rails-applications",
      "url": "/blogs/optimizing-rails-applications",
      "title": "Optimizing Rails Applications: Solving the N+1 Query Problem",
      "excerpt": "Learn how to identify and fix performance bottlenecks in Rails applications by addressing the common N+1 query issue...",
      "date": "January 22, 2025",
      "readTime": "2 min read",
      "tags": ["Ruby on Rails", "Performance", "Database"],
      "keywords": [ "N+1", "N+1 queries", "N plus one", "N plus one queries", "N+1 queries", "N+1 query", "N+1 query optimization", "N+1 query optimization", "N+1 problem", "N+1 problem solution", "Rails optimization", "Ruby on Rails performance", "Rails best practices", "Rails caching", "Rails N+1 queries", "Rails performance tips", "optimize Rails app" ],
      "content": "<p>One of the most common performance issues in Rails applications is the N+1 query problem. This occurs when your code executes N additional queries to fetch related data for N records, instead of fetching all the necessary data in a single query.</p><h2>Understanding the N+1 Problem</h2><p>Consider a situation where you have a blog with posts and comments. If you want to display all posts with their comments, a naive approach might look like this:</p><pre><code class=\"language-ruby\"># Controller index\n@posts = Post.all\n\n# In your view\n@posts.each do |post|\n  post.comments.each do |comment|\n    # Display comment\n  end\nend</code></pre><p>This code will execute one query to fetch all posts, and then one additional query for each post to fetch its comments. If you have 100 posts, this results in 101 database queries!</p><h2>Solution: Eager Loading</h2><p>Rails provides a simple solution through eager loading with the <code>includes</code> method:</p><pre><code class=\"language-ruby\">@posts = Post.includes(:comments).all</code></pre><p>This generates just two queries:</p><pre><code class=\"language-sql\">SELECT * FROM posts;\nSELECT * FROM comments WHERE post_id IN (1, 2, 3, ...);</code></pre><p>The <code>includes</code> method tells Rails to load the associated records in a separate query, and then merge the results in memory.</p><h2>Advanced Eager Loading</h2><p>For more complex relationships, you can nest your includes:</p><pre><code class=\"language-ruby\">@posts = Post.includes(comments: :user).all</code></pre><p>This will eager load comments and their associated users in just three queries, regardless of how many posts, comments, or users you have.</p><h2>Identifying N+1 Queries</h2><p>Tools like the Bullet gem can help you identify N+1 queries in your application. Add it to your Gemfile:</p><pre><code class=\"language-ruby\">gem 'bullet', group: :development</code></pre><p>Bullet will notify you when it detects N+1 queries in your application, helping you to identify and fix performance bottlenecks.</p><h2>Conclusion</h2><p>Solving N+1 query problems is one of the easiest ways to improve the performance of your Rails application. By using eager loading appropriately, you can dramatically reduce the number of database queries your application makes, resulting in faster response times and a better user experience.</p>"
    },
    {
      "id": 2,
      "slug": "finding-all-contiguous-subarrays-algorithmic-approach",
      "url": "/blogs/finding-all-contiguous-subarrays-algorithmic-approach",
      "title": "Finding All Contiguous Subarrays: An Algorithmic Approach",
      "excerpt": "Explore the connection between contiguous subarrays and arithmetic sequences.",
      "date": "May 26, 2025",
      "readTime": "4 min read",
      "tags": ["Algorithms", "Ruby", "Mathematics", "Data Structures"],
      "keywords": [
        "contiguous subarrays",
        "subarray algorithm",
        "arithmetic sequence",
        "algorithm optimization",
        "Ruby algorithms",
        "array manipulation",
        "mathematical validation",
        "O(n²) complexity",
        "algorithm assessment",
        "coding interview",
        "subarray generation",
        "pattern recognition",
        "algorithmic thinking",
        "competitive programming",
        "data structures"
      ],
      "content": "<p>Recently, while working on an algorithm assessment, I encountered an interesting problem: writing an algorithm to find all contiguous subarrays from a flat array like <code>[1,2,3,4,5]</code>. This challenge led me to discover a fascinating connection between contiguous subarrays and arithmetic sequences, which I'll explore in this article.</p><h2>Understanding Contiguous Subarrays</h2><p>A contiguous subarray is a sequence of elements that appear consecutively in the original array. For example, if we have an array <code>[1,2,3]</code>, all possible contiguous subarrays would be:</p><pre><code class=\"language-ruby\">[[1], [2], [3], [1,2], [2,3], [1,2,3]]</code></pre><p>The key insight I discovered is that the count of contiguous subarrays follows an arithmetic sequence pattern.</p><h2>The Arithmetic Sequence Connection</h2><p>When I analyzed the pattern of contiguous subarray counts, I noticed something interesting. For an array of length <code>n</code>, the number of subarrays starting at each position follows this pattern:</p><ul><li>Position 1: n subarrays</li><li>Position 2: n-1 subarrays</li><li>Position 3: n-2 subarrays</li><li>...</li><li>Position n: 1 subarray</li></ul><p>This creates the arithmetic sequence: <code>n + (n-1) + (n-2) + ... + 1</code></p><p>We can calculate this sum using the arithmetic sequence formula:</p><pre><code>S = (n/2)(first_element + last_element)\nS = (n/2)(n + 1)</code></pre><h2>Testing the Formula</h2><p>Let's verify this with some examples:</p><h3>Example 1: Array [1,2,3]</h3><p>All contiguous subarrays: <code>[[1],[2],[3],[1,2],[2,3],[1,2,3]]</code><br>Count: 6</p><p>Using the formula with n=3:</p><pre><code>S = (3/2)(3 + 1) = (3/2)(4) = 6 ✓</code></pre><h3>Example 2: Array [1,2,3,4,5]</h3><p>All contiguous subarrays: <code>[[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]</code><br>Count: 15</p><p>Using the formula with n=5:</p><pre><code>S = (5/2)(5 + 1) = (5/2)(6) = 15 ✓</code></pre><h2>The Algorithm Implementation</h2><p>Here's my Ruby solution for generating all contiguous subarrays with O(n²) time and space complexity:</p><pre><code class=\"language-ruby\">def all_contiguous_subarrays(nums)\n  vault = []\n  pointer = 0\n  \n  nums.each do |num|\n    temp_vault = vault.clone\n  \n    while pointer < temp_vault.length\n      arr = temp_vault[pointer]\n      vault << arr + [num]\n      pointer += 1\n    end\n  \n    vault << [num]\n    pointer = 0\n  end\n\n  vault\nend</code></pre><p>And the corresponding count validation function:</p><pre><code class=\"language-ruby\">def sub_array_count(num)\n  num * ((1 + num) / 2.0)\nend</code></pre><h2>Usage Example</h2><pre><code class=\"language-ruby\">c1 = [1,2,3,4]\nresult = all_contiguous_subarrays(c1)\n\n# Verify the count matches our formula\nputs result.length == sub_array_count(c1.length) # true</code></pre><h2>Performance Considerations</h2><p>The algorithm achieves O(n²) time complexity, which is optimal for this problem since we need to generate all possible contiguous subarrays. The space complexity is also O(n²) due to storing all subarrays.</p><p>For an array of length n, we generate exactly <code>n(n+1)/2</code> subarrays, making this the most efficient approach possible for complete subarray generation.</p><h2>Limitations and Testing Strategy</h2><p>It's important to note that using the arithmetic sequence formula only validates the count of subarrays, not their actual content. This approach provides a quick sanity check but shouldn't be the sole testing method for correctness.</p><p>For comprehensive testing, you'd want to verify:</p><ul><li>The correct count (using our formula)</li><li>Each subarray contains consecutive elements</li><li>No duplicate subarrays exist</li><li>All possible subarrays are included</li></ul><h2>Conclusion</h2><p>The connection between contiguous subarrays and arithmetic sequences provides an elegant way to validate our algorithm's completeness. While this mathematical relationship doesn't replace thorough testing, it offers valuable insight into the problem's structure and gives us confidence in our solution's correctness.</p><p>This approach demonstrates how understanding mathematical patterns can enhance our algorithmic thinking and provide elegant validation methods for complex problems.</p>"
    }

  ]
}

