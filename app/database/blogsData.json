{
  "blogPosts": [
    {
      "id": 4,
      "slug": "understanding-rails-view-rendering",
      "url": "/blogs/understanding-rails-view-rendering",
      "title": "Understanding Rails View Rendering: Behind the ERB Magic",
      "excerpt": "A deep dive into how Ruby on Rails transforms ERB templates into HTML, exploring the internal rendering process...",
      "date": "November 19, 2024",
      "readTime": "9 min read",
      "tags": ["Ruby on Rails", "ActionView", "ERB", "Ruby"],
      "content": "<p>Ruby on Rails encapsulates a lot of complexity, allowing developers to focus on writing features without worrying about its internal. For the longest time, I wanted to understand what exactly happens when render is invoked in a Rails controller. Specifically, I was curious about how Rails parses ERB tags (&lt;% %&gt;, &lt;%= %&gt;) in the view. This blog post is based on a recent talk I gave at my local Ruby meetup (September 2024 meeting · Luma).</p><p>This blog assumes the reader has a basic understanding of the Rails framework. If you're new to Rails, I recommend reading this guide to get familiar with the basics.</p><h2>For a contrived example</h2><p>Let's say we have a UsersController and its associated index view template.</p><pre><code class=\"language-ruby\">class UsersController < ApplicationController\n  def index\n    @user_email = \"shard@gmail.com\"\n  end\nend\n\n# app/views/users/index.html.erb\n# <ActionView::Base:0x00000000009bf0> instance view object\n\"<h1>Welcome  <%= @user_email %> to the Landing Page</h1>\"</code></pre><p>Views are rendered in the context of the ActionView::Base class.</p><h2>The Rendering Flow</h2><p>Let's visualize the rendering process before diving into the details:</p><ol><li>Controller Action called</li><li>Rails finds the ERB template</li><li>Template compiled to Ruby method</li><li>Method executes, generates HTML</li></ol><h2>The Transformation Process</h2><p>How does rails transform the HTML source code in the view template?</p><p>From:<br>\"&lt;h1&gt;Welcome  &lt;%= @user_email %&gt; to the Landing Page&lt;/h1&gt;\"</p><p>To:<br>\"&lt;h1&gt;Welcome shard@gmail.com to the Landing Page&lt;/h1&gt;\"</p><p>After exploring both the ActionPack and ActionView modules, which are the primary components responsible for handling requests, responses, and template rendering. Here's the breakdown of the rendering process that happens behind the scenes.</p><h2>The Rendering Process</h2><p>When def index action is called in a controller:</p><p>render is invoked implicitly in AbstractController::Rendering:23:</p><pre><code class=\"language-ruby\">def render(*args, &block)\n  options = _normalize_render(*args, &block)\n  rendered_body = render_to_body(options)\n  if options[:html]\n    _set_html_content_type\n  else\n    _set_rendered_content_type rendered_format\n  end\n  _set_vary_header\n  self.response_body = rendered_body\nend</code></pre><h3>1. _normalize_render (after Controller Action called):</h3><p>This method creates an options hash to provide context on the view template location and which view to render.</p><pre><code>options = { template: 'index', prefixes: [\"users\", \"application\"] }</code></pre><h3>2. render_to_body (find template):</h3><p>This method handles the actual view template rendering. Although render_to_body is called in several modules within ActionController and AbstractController, the render_to_body in ActionView::Rendering:105 is the key entry point for view rendering.</p><p>From there, ActionView looks up the template using the LookupContext class, parses the template path using the PathParser, and returns the extracted values in a hash.</p><pre><code>path = 'app/views/users/index.html.erb' \ndetails = {\n :prefix=>\"/Users/shardly/Documents/Main/Pet_Projects/shoe_stride/app/views/static_pages\", \n :action=>\"index\", \n :partial=>false, \n :locale=>nil, \n :handler=>:erb, \n :format=>:html, \n :variant=>nil\n}</code></pre><p>After some additional steps, an instance of the TemplateRenderer class creates an instance of the Template class, passing arguments like :handler(erb, haml), :format(HTML, js, etc), :variant (mobile, desktop) and a couple more.</p><h3>3. Compiled to Ruby method:</h3><p>Next, the compile method in the Template class is invoked, dynamically creating an instance method. Based on the HTML source code, the generated method would look like the example shown below.</p><pre><code class=\"language-ruby\">source = def _app_views_users_index_html_erb___3847165856814041552_19860(local_assigns, output_buffer)\n            @virtual_path = \"users/index\"\n            @output_buffer.safe_append='<h1>Welcome '.freeze\n            @output_buffer.append=( @user_email )\n            @output_buffer.safe_append=' to the Landing Page<h1>'.freeze;\n            @output_buffer.to_s\n          end</code></pre><p>The @output_buffer is an instance of the OutputBuffer class in the ActionView module. It is responsible for accumulating the rendered HTML content in Rails views. It is vital to manage how Ruby expressions, helpers, and templates are processed and outputted as complete HTML responses. It also ensures efficient rendering and proper HTML escaping.</p><p>The new instance method (`_app_views_users…`) is then added to the &lt;ActionView::Base:0x00000000009bf0&gt; class through module_eval:</p><pre><code class=\"language-ruby\"># mod = <ActionView::Base:0x00000000009bf0>\nmod.module_eval(source, identifier, 0)</code></pre><h3>4. Generate html:</h3><p>Finally, def _run is invoked on the ActionView::Base object, which in turn calls public_send, invoking the dynamically created method:</p><pre><code class=\"language-ruby\"># method = \"_app_views_users_index_html_erb___3847165856814041552_19860\"\n\ndef _run(method, template, locals, buffer, add_to_stack: true, &block)\n  _old_output_buffer, _old_virtual_path, _old_template = @output_buffer, @virtual_path, @current_template\n  @current_template = template if add_to_stack\n  @output_buffer = buffer\n  public_send(method, locals, buffer, &block)</code></pre><p>public_send will return:</p><pre><code>\"<h1>Welcome shard@gmail.com to the Landing Page<h1>\"</code></pre><p>That's it!</p><h2>Wrapping Up</h2><p>A key takeaway here is how Rails dynamically creates and evaluates methods during template rendering. Ruby allows you to use module_eval to define methods on the fly on a class, such as in this example:</p><pre><code class=\"language-ruby\">class Post\nend\n\npost = Post.new\n\nPost.module_eval do\n  def comment\n    'my comment'\n  end\nend\n\npost.comment #=> \"my comment\"</code></pre><p>Rails modules come with built-in debugging tools like debugger, which made this research much easier. You can open a module in your preferred IDE by running:</p><pre><code>$ sample_rails_project git:(main) > EDITOR=code bundle open actionview\n$ sample_rails_project git:(main) > EDITOR=code bundle open actionpack</code></pre><p>If you make any changes while exploring, you can reset the files to their original state by running:</p><pre><code>$ sample_rails_project git:(main) > gem pristine actionview\n$ sample_rails_project git:(main) > gem pristine actionpack</code></pre><h2>Conclusion</h2><p>Exploring Rails' source code has deepened my appreciation for the framework, and I learned some interesting Ruby concepts along the way. The framework extensively follows the SOLID principles, with the Single Responsibility Principle being particularly evident in many of its classes. Through this research, I also discovered some text documentation that needs to be updated in the ActionPack module, for which I have submitted a pull request. I hope this blog post empowers you to explore the underlying mechanics of the tools you're using.</p><p>Go out and explore yourself it is a rewarding experience.</p><p>Thanks for reading!</p>"
    },
    {
      "id": 1,
      "slug": "optimizing-rails-applications",
      "url": "/blogs/optimizing-rails-applications",
      "title": "Optimizing Rails Applications: Solving the N+1 Query Problem",
      "excerpt": "Learn how to identify and fix performance bottlenecks in Rails applications by addressing the common N+1 query issue...",
      "date": "March 15, 2023",
      "readTime": "8 min read",
      "tags": ["Ruby on Rails", "Performance", "Database"],
      "content": "<p>One of the most common performance issues in Rails applications is the N+1 query problem. This occurs when your code executes N additional queries to fetch related data for N records, instead of fetching all the necessary data in a single query.</p><h2>Understanding the N+1 Problem</h2><p>Consider a situation where you have a blog with posts and comments. If you want to display all posts with their comments, a naive approach might look like this:</p><pre><code class=\"language-ruby\">@posts = Post.all\n\n# In your view\n@posts.each do |post|\n  post.comments.each do |comment|\n    # Display comment\n  end\nend</code></pre><p>This code will execute one query to fetch all posts, and then one additional query for each post to fetch its comments. If you have 100 posts, this results in 101 database queries!</p><h2>Solution: Eager Loading</h2><p>Rails provides a simple solution through eager loading with the <code>includes</code> method:</p><pre><code class=\"language-ruby\">@posts = Post.includes(:comments).all</code></pre><p>This generates just two queries:</p><pre><code class=\"language-sql\">SELECT * FROM posts;\nSELECT * FROM comments WHERE post_id IN (1, 2, 3, ...);</code></pre><p>The <code>includes</code> method tells Rails to load the associated records in a separate query, and then merge the results in memory.</p><h2>Advanced Eager Loading</h2><p>For more complex relationships, you can nest your includes:</p><pre><code class=\"language-ruby\">@posts = Post.includes(comments: :user).all</code></pre><p>This will eager load comments and their associated users in just three queries, regardless of how many posts, comments, or users you have.</p><h2>Identifying N+1 Queries</h2><p>Tools like the Bullet gem can help you identify N+1 queries in your application. Add it to your Gemfile:</p><pre><code class=\"language-ruby\">gem 'bullet', group: :development</code></pre><p>Bullet will notify you when it detects N+1 queries in your application, helping you to identify and fix performance bottlenecks.</p><h2>Conclusion</h2><p>Solving N+1 query problems is one of the easiest ways to improve the performance of your Rails application. By using eager loading appropriately, you can dramatically reduce the number of database queries your application makes, resulting in faster response times and a better user experience.</p>"
    },
    {
      "id": 2,
      "slug": "real-time-applications-websockets",
      "url": "/blogs/real-time-applications-websockets",
      "title": "Building Real-time Applications with WebSockets",
      "excerpt": "Explore the implementation of WebSockets for creating responsive, real-time features in modern web applications...",
      "date": "January 20, 2023",
      "readTime": "10 min read",
      "tags": ["WebSockets", "JavaScript", "Real-time"],
      "content": "<p>In today's web landscape, users expect real-time updates and interactions. Traditional HTTP request-response cycles fall short for applications like chat, live notifications, or collaborative editing. This is where WebSockets come in.</p><h2>What are WebSockets?</h2><p>WebSockets provide a persistent connection between a client and server, allowing for bi-directional, full-duplex communication. Unlike HTTP, where the client must initiate all interactions, WebSockets allow both the client and server to send messages at any time.</p><pre><code class=\"language-javascript\">// Establishing a WebSocket connection\nconst socket = new WebSocket('ws://example.com/socket');\n\n// Listening for messages\nsocket.onmessage = (event) => {\n  const message = JSON.parse(event.data);\n  console.log('Message from server:', message);\n};\n\n// Sending a message to the server\nsocket.send(JSON.stringify({ type: 'chat', content: 'Hello, world!' }));</code></pre><h2>WebSocket Handshake</h2><p>A WebSocket connection starts as an HTTP request that includes an Upgrade header, requesting to switch protocols. If the server supports WebSockets, it responds with a 101 status code and the connection remains open as a WebSocket connection.</p><h2>Building a Simple Chat Application</h2><p>Let's create a basic chat room using WebSockets. We'll use Node.js with the 'ws' library for the server:</p><pre><code class=\"language-javascript\">// Server code\nconst WebSocket = require('ws');\nconst server = new WebSocket.Server({ port: 8080 });\n\nserver.on('connection', (socket) => {\n  socket.on('message', (message) => {\n    // Broadcast message to all connected clients\n    server.clients.forEach((client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(message);\n      }\n    });\n  });\n});</code></pre><p>And on the client side:</p><pre><code class=\"language-javascript\">// Client code\nconst socket = new WebSocket('ws://localhost:8080');\nconst messageList = document.querySelector('#messages');\nconst messageInput = document.querySelector('#messageInput');\nconst sendButton = document.querySelector('#sendButton');\n\nsocket.onmessage = (event) => {\n  const message = document.createElement('li');\n  message.textContent = event.data;\n  messageList.appendChild(message);\n};\n\nsendButton.addEventListener('click', () => {\n  const message = messageInput.value;\n  socket.send(message);\n  messageInput.value = '';\n});</code></pre><h2>Handling Connection Issues</h2><p>WebSocket connections can close for various reasons. It's important to handle reconnection gracefully:</p><pre><code class=\"language-javascript\">function connect() {\n  const socket = new WebSocket('ws://localhost:8080');\n  \n  socket.onclose = function(event) {\n    console.log('Socket closed. Reconnecting...', event.reason);\n    // Attempt to reconnect after a delay\n    setTimeout(connect, 1000);\n  };\n  \n  socket.onerror = function(error) {\n    console.error('Socket error:', error);\n    socket.close();\n  };\n  \n  return socket;\n}\n\nlet socket = connect();</code></pre><h2>Scaling WebSockets</h2><p>As your application grows, you'll need to consider how to scale your WebSocket implementation. Solutions include:</p><ul><li>Using Redis pub/sub to broadcast messages across multiple server instances</li><li>Implementing a load balancer with sticky sessions</li><li>Using specialized WebSocket services like Socket.io or Pusher</li></ul><h2>Conclusion</h2><p>WebSockets are a powerful tool for building real-time web applications. They enable features that simply weren't possible with traditional HTTP requests. By understanding how to implement and scale WebSocket connections, you can create engaging, responsive user experiences in your web applications.</p>"
    },
    {
      "id": 3,
      "slug": "react-custom-hooks",
      "url": "/blogs/react-custom-hooks",
      "title": "Creating Reusable Logic with React Custom Hooks",
      "excerpt": "Learn how to extract and reuse stateful logic across components with React's custom hooks...",
      "date": "April 5, 2023",
      "readTime": "7 min read",
      "tags": ["React", "JavaScript", "Hooks"],
      "content": "<p>React's introduction of Hooks revolutionized how we manage state and side effects in functional components. While built-in hooks like useState and useEffect are powerful, custom hooks truly unlock React's potential by allowing developers to extract and reuse stateful logic.</p><h2>What Are Custom Hooks?</h2><p>Custom hooks are JavaScript functions that start with the word \"use\" and may call other hooks. This naming convention isn't just for consistency—it's how React identifies functions that may use hook features.</p><pre><code class=\"language-javascript\">// A simple custom hook\nfunction useWindowSize() {\n  const [windowSize, setWindowSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowSize;\n}</code></pre><h2>Building a useLocalStorage Hook</h2><p>Let's create a custom hook that synchronizes component state with localStorage:</p><pre><code class=\"language-javascript\">function useLocalStorage(key, initialValue) {\n  // State to store our value\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or if none return initialValue\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.error(error);\n      return initialValue;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      // Save state\n      setStoredValue(valueToStore);\n      // Save to local storage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}</code></pre><p>Now we can use this hook in any component:</p><pre><code class=\"language-javascript\">function App() {\n  const [name, setName] = useLocalStorage('name', 'John');\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n    </div>\n  );\n}</code></pre><h2>Creating a useFetch Hook</h2><p>Another common pattern is data fetching. Let's build a hook for that:</p><pre><code class=\"language-javascript\">function useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (e) {\n        setError(e.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}</code></pre><p>Using this hook makes data fetching concise and reusable:</p><pre><code class=\"language-javascript\">function UserProfile({ id }) {\n  const { data, loading, error } = useFetch(`https://api.example.com/users/${id}`);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n  \n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.email}</p>\n    </div>\n  );\n}</code></pre><h2>Best Practices for Custom Hooks</h2><ul><li><strong>Keep them focused</strong>: Each hook should solve one specific problem.</li><li><strong>Name them clearly</strong>: The name should clearly indicate what the hook does.</li><li><strong>Document your hooks</strong>: Include JSDoc comments to explain parameters and return values.</li><li><strong>Handle errors gracefully</strong>: Ensure your hooks handle error states appropriately.</li><li><strong>Test them independently</strong>: Custom hooks can and should be tested in isolation.</li></ul><h2>Conclusion</h2><p>Custom hooks are a powerful pattern in React that lets you extract component logic into reusable functions. They help keep your components clean and focused on presentation while encapsulating complex logic in well-named, reusable functions. By following the examples and best practices outlined above, you'll be able to leverage custom hooks to create more maintainable and elegant React applications.</p>"
    }
  ]
}

